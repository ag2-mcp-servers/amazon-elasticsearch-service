# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T11:24:32+00:00



import argparse
import json
import os
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import APIKeyHeader, BaseSecurity
from fastapi import Header, Path, Query
from pydantic import conint, constr

from models import (
    AcceptInboundCrossClusterSearchConnectionResponse,
    AccessDeniedException,
    AssociatePackageResponse,
    AuthorizeVpcEndpointAccessResponse,
    BaseException,
    CancelElasticsearchServiceSoftwareUpdateResponse,
    ConflictException,
    CreateElasticsearchDomainResponse,
    CreateOutboundCrossClusterSearchConnectionResponse,
    CreatePackageResponse,
    CreateVpcEndpointResponse,
    DeleteElasticsearchDomainResponse,
    DeleteInboundCrossClusterSearchConnectionResponse,
    DeleteOutboundCrossClusterSearchConnectionResponse,
    DeletePackageResponse,
    DeleteVpcEndpointResponse,
    DescribeDomainAutoTunesResponse,
    DescribeDomainChangeProgressResponse,
    DescribeElasticsearchDomainConfigResponse,
    DescribeElasticsearchDomainResponse,
    DescribeElasticsearchDomainsResponse,
    DescribeElasticsearchInstanceTypeLimitsResponse,
    DescribeInboundCrossClusterSearchConnectionsResponse,
    DescribeOutboundCrossClusterSearchConnectionsResponse,
    DescribePackagesResponse,
    DescribeReservedElasticsearchInstanceOfferingsResponse,
    DescribeReservedElasticsearchInstancesResponse,
    DescribeVpcEndpointsResponse,
    DisabledOperationException,
    DissociatePackageResponse,
    EngineType,
    Field20150101EsCcsInboundConnectionSearchPostRequest,
    Field20150101EsCcsOutboundConnectionPostRequest,
    Field20150101EsCcsOutboundConnectionSearchPostRequest,
    Field20150101EsDomainDomainNameAuthorizeVpcEndpointAccessPostRequest,
    Field20150101EsDomainDomainNameAutoTunesGetRequest,
    Field20150101EsDomainDomainNameConfigPostRequest,
    Field20150101EsDomainDomainNameRevokeVpcEndpointAccessPostRequest,
    Field20150101EsDomainInfoPostRequest,
    Field20150101EsDomainPostRequest,
    Field20150101EsPurchaseReservedInstanceOfferingPostRequest,
    Field20150101EsServiceSoftwareUpdateCancelPostRequest,
    Field20150101EsServiceSoftwareUpdateStartPostRequest,
    Field20150101EsUpgradeDomainPostRequest,
    Field20150101EsVpcEndpointsDescribePostRequest,
    Field20150101EsVpcEndpointsPostRequest,
    Field20150101EsVpcEndpointsUpdatePostRequest,
    Field20150101PackagesDescribePostRequest,
    Field20150101PackagesPostRequest,
    Field20150101PackagesUpdatePostRequest,
    Field20150101TagsPostRequest,
    Field20150101TagsRemovalPostRequest,
    GetCompatibleElasticsearchVersionsResponse,
    GetPackageVersionHistoryResponse,
    GetUpgradeHistoryResponse,
    GetUpgradeStatusResponse,
    InstanceType,
    InternalException,
    InvalidPaginationTokenException,
    InvalidTypeException,
    LimitExceededException,
    ListDomainNamesResponse,
    ListDomainsForPackageResponse,
    ListElasticsearchInstanceTypesResponse,
    ListElasticsearchVersionsResponse,
    ListPackagesForDomainResponse,
    ListTagsResponse,
    ListVpcEndpointAccessResponse,
    ListVpcEndpointsForDomainResponse,
    ListVpcEndpointsResponse,
    PurchaseReservedElasticsearchInstanceOfferingResponse,
    RejectInboundCrossClusterSearchConnectionResponse,
    ResourceAlreadyExistsException,
    ResourceNotFoundException,
    RevokeVpcEndpointAccessResponse,
    StartElasticsearchServiceSoftwareUpdateResponse,
    UpdateElasticsearchDomainConfigResponse,
    UpdatePackageResponse,
    UpdateVpcEndpointResponse,
    UpgradeElasticsearchDomainResponse,
    ValidationException,
)

app = MCPProxy(
    contact={
        'email': 'mike.ralphson@gmail.com',
        'name': 'Mike Ralphson',
        'url': 'https://github.com/mermade/aws2openapi',
        'x-twitter': 'PermittedSoc',
    },
    description='<fullname>Amazon Elasticsearch Configuration Service</fullname> <p>Use the Amazon Elasticsearch Configuration API to create, configure, and manage Elasticsearch domains.</p> <p>For sample code that uses the Configuration API, see the <a href="https://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-configuration-samples.html">Amazon Elasticsearch Service Developer Guide</a>. The guide also contains <a href="https://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-request-signing.html">sample code for sending signed HTTP requests to the Elasticsearch APIs</a>.</p> <p>The endpoint for configuration service requests is region-specific: es.<i>region</i>.amazonaws.com. For example, es.us-east-1.amazonaws.com. For a current list of supported regions and endpoints, see <a href="http://docs.aws.amazon.com/general/latest/gr/rande.html#elasticsearch-service-regions" target="_blank">Regions and Endpoints</a>.</p>',
    license={'name': 'Apache 2.0 License', 'url': 'http://www.apache.org/licenses/'},
    termsOfService='https://aws.amazon.com/service-terms/',
    title='Amazon Elasticsearch Service',
    version='2015-01-01',
    servers=[
        {
            'description': 'The Amazon Elasticsearch Service multi-region endpoint',
            'url': 'http://es.{region}.amazonaws.com',
            'variables': {
                'region': {
                    'default': 'us-east-1',
                    'description': 'The AWS region',
                    'enum': [
                        'us-east-1',
                        'us-east-2',
                        'us-west-1',
                        'us-west-2',
                        'us-gov-west-1',
                        'us-gov-east-1',
                        'ca-central-1',
                        'eu-north-1',
                        'eu-west-1',
                        'eu-west-2',
                        'eu-west-3',
                        'eu-central-1',
                        'eu-south-1',
                        'af-south-1',
                        'ap-northeast-1',
                        'ap-northeast-2',
                        'ap-northeast-3',
                        'ap-southeast-1',
                        'ap-southeast-2',
                        'ap-east-1',
                        'ap-south-1',
                        'sa-east-1',
                        'me-south-1',
                    ],
                }
            },
        },
        {
            'description': 'The Amazon Elasticsearch Service multi-region endpoint',
            'url': 'https://es.{region}.amazonaws.com',
            'variables': {
                'region': {
                    'default': 'us-east-1',
                    'description': 'The AWS region',
                    'enum': [
                        'us-east-1',
                        'us-east-2',
                        'us-west-1',
                        'us-west-2',
                        'us-gov-west-1',
                        'us-gov-east-1',
                        'ca-central-1',
                        'eu-north-1',
                        'eu-west-1',
                        'eu-west-2',
                        'eu-west-3',
                        'eu-central-1',
                        'eu-south-1',
                        'af-south-1',
                        'ap-northeast-1',
                        'ap-northeast-2',
                        'ap-northeast-3',
                        'ap-southeast-1',
                        'ap-southeast-2',
                        'ap-east-1',
                        'ap-south-1',
                        'sa-east-1',
                        'me-south-1',
                    ],
                }
            },
        },
        {
            'description': 'The Amazon Elasticsearch Service endpoint for China (Beijing) and China (Ningxia)',
            'url': 'http://es.{region}.amazonaws.com.cn',
            'variables': {
                'region': {
                    'default': 'cn-north-1',
                    'description': 'The AWS region',
                    'enum': ['cn-north-1', 'cn-northwest-1'],
                }
            },
        },
        {
            'description': 'The Amazon Elasticsearch Service endpoint for China (Beijing) and China (Ningxia)',
            'url': 'https://es.{region}.amazonaws.com.cn',
            'variables': {
                'region': {
                    'default': 'cn-north-1',
                    'description': 'The AWS region',
                    'enum': ['cn-north-1', 'cn-northwest-1'],
                }
            },
        },
    ],
)


@app.get(
    '/2015-01-01/domain',
    description=""" Returns the name of all Elasticsearch domains owned by the current user's account.  """,
    tags=['vpc_access_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_domain_names(
    engine_type: Optional[EngineType] = Query(None, alias='engineType'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2015-01-01/domain/{DomainName}/packages',
    description=""" Lists all packages associated with the Amazon ES domain. """,
    tags=['domain_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_packages_for_domain(
    domain_name: constr(
        pattern=r'[a-z][a-z0-9\-]+', min_length=3, max_length=28
    ) = Path(..., alias='DomainName'),
    max_results: Union[
        Optional[conint(le=100)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='maxResults'),
    next_token: Union[
        Optional[str], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='nextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2015-01-01/es/ccs/inboundConnection/search',
    description=""" Lists all the inbound cross-cluster search connections for a destination domain. """,
    tags=['cross_cluster_search_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def describe_inbound_cross_cluster_search_connections(
    max_results: Optional[str] = Query(None, alias='MaxResults'),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: Field20150101EsCcsInboundConnectionSearchPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/2015-01-01/es/ccs/inboundConnection/{ConnectionId}',
    description=""" Allows the destination domain owner to delete an existing inbound cross-cluster search connection. """,
    tags=['cross_cluster_search_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_inbound_cross_cluster_search_connection(
    connection_id: str = Path(..., alias='ConnectionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/2015-01-01/es/ccs/inboundConnection/{ConnectionId}/accept',
    description=""" Allows the destination domain owner to accept an inbound cross-cluster search connection request. """,
    tags=['cross_cluster_search_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def accept_inbound_cross_cluster_search_connection(
    connection_id: str = Path(..., alias='ConnectionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/2015-01-01/es/ccs/inboundConnection/{ConnectionId}/reject',
    description=""" Allows the destination domain owner to reject an inbound cross-cluster search connection request. """,
    tags=['cross_cluster_search_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def reject_inbound_cross_cluster_search_connection(
    connection_id: str = Path(..., alias='ConnectionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2015-01-01/es/ccs/outboundConnection',
    description=""" Creates a new cross-cluster search connection from a source domain to a destination domain. """,
    tags=['cross_cluster_search_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_outbound_cross_cluster_search_connection(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: Field20150101EsCcsOutboundConnectionPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2015-01-01/es/ccs/outboundConnection/search',
    description=""" Lists all the outbound cross-cluster search connections for a source domain. """,
    tags=['cross_cluster_search_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def describe_outbound_cross_cluster_search_connections(
    max_results: Optional[str] = Query(None, alias='MaxResults'),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: Field20150101EsCcsOutboundConnectionSearchPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/2015-01-01/es/ccs/outboundConnection/{ConnectionId}',
    description=""" Allows the source domain owner to delete an existing outbound cross-cluster search connection. """,
    tags=['cross_cluster_search_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_outbound_cross_cluster_search_connection(
    connection_id: str = Path(..., alias='ConnectionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2015-01-01/es/compatibleVersions',
    description="""  Returns a list of upgrade compatible Elastisearch versions. You can optionally pass a <code> <a>DomainName</a> </code> to get all upgrade compatible Elasticsearch versions for that specific domain.  """,
    tags=['domain_management', 'vpc_access_management', 'resource_tag_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_compatible_elasticsearch_versions(
    domain_name: Optional[
        constr(pattern=r'[a-z][a-z0-9\-]+', min_length=3, max_length=28)
    ] = Query(None, alias='domainName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2015-01-01/es/domain',
    description=""" Creates a new Elasticsearch domain. For more information, see <a href="http://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-createupdatedomains.html#es-createdomains" target="_blank">Creating Elasticsearch Domains</a> in the <i>Amazon Elasticsearch Service Developer Guide</i>. """,
    tags=['domain_management', 'vpc_access_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_elasticsearch_domain(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: Field20150101EsDomainPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2015-01-01/es/domain-info',
    description=""" Returns domain configuration information about the specified Elasticsearch domains, including the domain ID, domain endpoint, and domain ARN. """,
    tags=['vpc_access_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def describe_elasticsearch_domains(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: Field20150101EsDomainInfoPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/2015-01-01/es/domain/{DomainName}',
    description=""" Permanently deletes the specified Elasticsearch domain and all of its data. Once a domain is deleted, it cannot be recovered. """,
    tags=['domain_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_elasticsearch_domain(
    domain_name: constr(
        pattern=r'[a-z][a-z0-9\-]+', min_length=3, max_length=28
    ) = Path(..., alias='DomainName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2015-01-01/es/domain/{DomainName}',
    description=""" Returns domain configuration information about the specified Elasticsearch domain, including the domain ID, domain endpoint, and domain ARN. """,
    tags=['domain_management', 'vpc_access_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def describe_elasticsearch_domain(
    domain_name: constr(
        pattern=r'[a-z][a-z0-9\-]+', min_length=3, max_length=28
    ) = Path(..., alias='DomainName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2015-01-01/es/domain/{DomainName}/authorizeVpcEndpointAccess',
    description=""" Provides access to an Amazon OpenSearch Service domain through the use of an interface VPC endpoint. """,
    tags=['vpc_access_management', 'domain_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def authorize_vpc_endpoint_access(
    domain_name: constr(
        pattern=r'[a-z][a-z0-9\-]+', min_length=3, max_length=28
    ) = Path(..., alias='DomainName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: Field20150101EsDomainDomainNameAuthorizeVpcEndpointAccessPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2015-01-01/es/domain/{DomainName}/autoTunes',
    description=""" Provides scheduled Auto-Tune action details for the Elasticsearch domain, such as Auto-Tune action type, description, severity, and scheduled date. """,
    tags=['domain_management', 'auto_tuning_configuration_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def describe_domain_auto_tunes(
    domain_name: constr(
        pattern=r'[a-z][a-z0-9\-]+', min_length=3, max_length=28
    ) = Path(..., alias='DomainName'),
    max_results: Optional[str] = Query(None, alias='MaxResults'),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: Field20150101EsDomainDomainNameAutoTunesGetRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2015-01-01/es/domain/{DomainName}/config',
    description=""" Provides cluster configuration information about the specified Elasticsearch domain, such as the state, creation date, update version, and update date for cluster options. """,
    tags=['domain_management', 'vpc_access_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def describe_elasticsearch_domain_config(
    domain_name: constr(
        pattern=r'[a-z][a-z0-9\-]+', min_length=3, max_length=28
    ) = Path(..., alias='DomainName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2015-01-01/es/domain/{DomainName}/config',
    description=""" Modifies the cluster configuration of the specified Elasticsearch domain, setting as setting the instance type and the number of instances.  """,
    tags=['domain_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_elasticsearch_domain_config(
    domain_name: constr(
        pattern=r'[a-z][a-z0-9\-]+', min_length=3, max_length=28
    ) = Path(..., alias='DomainName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: Field20150101EsDomainDomainNameConfigPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2015-01-01/es/domain/{DomainName}/listVpcEndpointAccess',
    description=""" Retrieves information about each principal that is allowed to access a given Amazon OpenSearch Service domain through the use of an interface VPC endpoint. """,
    tags=['domain_management', 'domain_upgrade_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_vpc_endpoint_access(
    domain_name: constr(
        pattern=r'[a-z][a-z0-9\-]+', min_length=3, max_length=28
    ) = Path(..., alias='DomainName'),
    next_token: Optional[str] = Query(None, alias='nextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2015-01-01/es/domain/{DomainName}/progress',
    description=""" Returns information about the current blue/green deployment happening on a domain, including a change ID, status, and progress stages. """,
    tags=['domain_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def describe_domain_change_progress(
    domain_name: constr(
        pattern=r'[a-z][a-z0-9\-]+', min_length=3, max_length=28
    ) = Path(..., alias='DomainName'),
    changeid: Optional[
        constr(
            pattern=r'\p{XDigit}{8}-\p{XDigit}{4}-\p{XDigit}{4}-\p{XDigit}{4}-\p{XDigit}{12}'
        )
    ] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2015-01-01/es/domain/{DomainName}/revokeVpcEndpointAccess',
    description=""" Revokes access to an Amazon OpenSearch Service domain that was provided through an interface VPC endpoint. """,
    tags=['vpc_access_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def revoke_vpc_endpoint_access(
    domain_name: constr(
        pattern=r'[a-z][a-z0-9\-]+', min_length=3, max_length=28
    ) = Path(..., alias='DomainName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: Field20150101EsDomainDomainNameRevokeVpcEndpointAccessPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2015-01-01/es/domain/{DomainName}/vpcEndpoints',
    description=""" Retrieves all Amazon OpenSearch Service-managed VPC endpoints associated with a particular domain. """,
    tags=['domain_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_vpc_endpoints_for_domain(
    domain_name: constr(
        pattern=r'[a-z][a-z0-9\-]+', min_length=3, max_length=28
    ) = Path(..., alias='DomainName'),
    next_token: Optional[str] = Query(None, alias='nextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2015-01-01/es/instanceTypeLimits/{ElasticsearchVersion}/{InstanceType}',
    description="""  Describe Elasticsearch Limits for a given InstanceType and ElasticsearchVersion. When modifying existing Domain, specify the <code> <a>DomainName</a> </code> to know what Limits are supported for modifying.  """,
    tags=[
        'domain_management',
        'instance_type_management',
        'version_compatibility_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def describe_elasticsearch_instance_type_limits(
    domain_name: Optional[
        constr(pattern=r'[a-z][a-z0-9\-]+', min_length=3, max_length=28)
    ] = Query(None, alias='domainName'),
    instance_type: InstanceType = Path(..., alias='InstanceType'),
    elasticsearch_version: constr(
        pattern=r'^[0-9]{1}\.[0-9]{1,2}$|^OpenSearch_[0-9]{1,2}\.[0-9]{1,2}$'
    ) = Path(..., alias='ElasticsearchVersion'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2015-01-01/es/instanceTypes/{ElasticsearchVersion}',
    description=""" List all Elasticsearch instance types that are supported for given ElasticsearchVersion """,
    tags=['domain_management', 'version_compatibility_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_elasticsearch_instance_types(
    elasticsearch_version: constr(
        pattern=r'^[0-9]{1}\.[0-9]{1,2}$|^OpenSearch_[0-9]{1,2}\.[0-9]{1,2}$'
    ) = Path(..., alias='ElasticsearchVersion'),
    domain_name: Optional[
        constr(pattern=r'[a-z][a-z0-9\-]+', min_length=3, max_length=28)
    ] = Query(None, alias='domainName'),
    max_results: Union[
        Optional[conint(le=100)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='maxResults'),
    next_token: Union[
        Optional[str], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='nextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2015-01-01/es/purchaseReservedInstanceOffering',
    description=""" Allows you to purchase reserved Elasticsearch instances. """,
    tags=['domain_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def purchase_reserved_elasticsearch_instance_offering(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: Field20150101EsPurchaseReservedInstanceOfferingPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2015-01-01/es/reservedInstanceOfferings',
    description=""" Lists available reserved Elasticsearch instance offerings. """,
    tags=['domain_management', 'vpc_access_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def describe_reserved_elasticsearch_instance_offerings(
    offering_id: Optional[
        constr(
            pattern=r'\p{XDigit}{8}-\p{XDigit}{4}-\p{XDigit}{4}-\p{XDigit}{4}-\p{XDigit}{12}'
        )
    ] = Query(None, alias='offeringId'),
    max_results: Union[
        Optional[conint(le=100)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='maxResults'),
    next_token: Union[
        Optional[str], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='nextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2015-01-01/es/reservedInstances',
    description=""" Returns information about reserved Elasticsearch instances for this account. """,
    tags=['domain_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def describe_reserved_elasticsearch_instances(
    reservation_id: Optional[
        constr(
            pattern=r'\p{XDigit}{8}-\p{XDigit}{4}-\p{XDigit}{4}-\p{XDigit}{4}-\p{XDigit}{12}'
        )
    ] = Query(None, alias='reservationId'),
    max_results: Union[
        Optional[conint(le=100)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='maxResults'),
    next_token: Union[
        Optional[str], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='nextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/2015-01-01/es/role',
    description=""" Deletes the service-linked role that Elasticsearch Service uses to manage and maintain VPC domains. Role deletion will fail if any existing VPC domains use the role. You must delete any such Elasticsearch domains before deleting the role. See <a href="http://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-vpc.html#es-enabling-slr" target="_blank">Deleting Elasticsearch Service Role</a> in <i>VPC Endpoints for Amazon Elasticsearch Service Domains</i>. """,
    tags=['vpc_access_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_elasticsearch_service_role(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2015-01-01/es/serviceSoftwareUpdate/cancel',
    description=""" Cancels a scheduled service software update for an Amazon ES domain. You can only perform this operation before the <code>AutomatedUpdateDate</code> and when the <code>UpdateStatus</code> is in the <code>PENDING_UPDATE</code> state. """,
    tags=['service_update_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def cancel_elasticsearch_service_software_update(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: Field20150101EsServiceSoftwareUpdateCancelPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2015-01-01/es/serviceSoftwareUpdate/start',
    description=""" Schedules a service software update for an Amazon ES domain. """,
    tags=['service_update_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def start_elasticsearch_service_software_update(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: Field20150101EsServiceSoftwareUpdateStartPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2015-01-01/es/upgradeDomain',
    description=""" Allows you to either upgrade your domain or perform an Upgrade eligibility check to a compatible Elasticsearch version. """,
    tags=['domain_management', 'domain_upgrade_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def upgrade_elasticsearch_domain(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: Field20150101EsUpgradeDomainPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2015-01-01/es/upgradeDomain/{DomainName}/history',
    description=""" Retrieves the complete history of the last 10 upgrades that were performed on the domain. """,
    tags=['domain_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_upgrade_history(
    domain_name: constr(
        pattern=r'[a-z][a-z0-9\-]+', min_length=3, max_length=28
    ) = Path(..., alias='DomainName'),
    max_results: Union[
        Optional[conint(le=100)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='maxResults'),
    next_token: Union[
        Optional[str], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='nextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2015-01-01/es/upgradeDomain/{DomainName}/status',
    description=""" Retrieves the latest status of the last upgrade or upgrade eligibility check that was performed on the domain. """,
    tags=['domain_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_upgrade_status(
    domain_name: constr(
        pattern=r'[a-z][a-z0-9\-]+', min_length=3, max_length=28
    ) = Path(..., alias='DomainName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2015-01-01/es/versions',
    description=""" List all supported Elasticsearch versions """,
    tags=['vpc_access_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_elasticsearch_versions(
    max_results: Union[
        Optional[conint(le=100)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='maxResults'),
    next_token: Union[
        Optional[str], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='nextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2015-01-01/es/vpcEndpoints',
    description=""" Retrieves all Amazon OpenSearch Service-managed VPC endpoints in the current account and Region. """,
    tags=['vpc_access_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_vpc_endpoints(
    next_token: Optional[str] = Query(None, alias='nextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2015-01-01/es/vpcEndpoints',
    description=""" Creates an Amazon OpenSearch Service-managed VPC endpoint. """,
    tags=['vpc_access_management', 'vpc_endpoint_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_vpc_endpoint(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: Field20150101EsVpcEndpointsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2015-01-01/es/vpcEndpoints/describe',
    description=""" Describes one or more Amazon OpenSearch Service-managed VPC endpoints. """,
    tags=['vpc_access_management', 'vpc_endpoint_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def describe_vpc_endpoints(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: Field20150101EsVpcEndpointsDescribePostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2015-01-01/es/vpcEndpoints/update',
    description=""" Modifies an Amazon OpenSearch Service-managed interface VPC endpoint. """,
    tags=['vpc_access_management', 'vpc_endpoint_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_vpc_endpoint(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: Field20150101EsVpcEndpointsUpdatePostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/2015-01-01/es/vpcEndpoints/{VpcEndpointId}',
    description=""" Deletes an Amazon OpenSearch Service-managed interface VPC endpoint. """,
    tags=['vpc_access_management', 'vpc_endpoint_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_vpc_endpoint(
    vpc_endpoint_id: constr(
        pattern=r'^aos-[a-zA-Z0-9]*$', min_length=5, max_length=256
    ) = Path(..., alias='VpcEndpointId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2015-01-01/packages',
    description=""" Create a package for use with Amazon ES domains. """,
    tags=['package_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_package(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: Field20150101PackagesPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2015-01-01/packages/associate/{PackageID}/{DomainName}',
    description=""" Associates a package with an Amazon ES domain. """,
    tags=['package_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def associate_package(
    package_i_d: str = Path(..., alias='PackageID'),
    domain_name: constr(
        pattern=r'[a-z][a-z0-9\-]+', min_length=3, max_length=28
    ) = Path(..., alias='DomainName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2015-01-01/packages/describe',
    description=""" Describes all packages available to Amazon ES. Includes options for filtering, limiting the number of results, and pagination. """,
    tags=['package_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def describe_packages(
    max_results: Optional[str] = Query(None, alias='MaxResults'),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: Field20150101PackagesDescribePostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2015-01-01/packages/dissociate/{PackageID}/{DomainName}',
    description=""" Dissociates a package from the Amazon ES domain. """,
    tags=['package_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def dissociate_package(
    package_i_d: str = Path(..., alias='PackageID'),
    domain_name: constr(
        pattern=r'[a-z][a-z0-9\-]+', min_length=3, max_length=28
    ) = Path(..., alias='DomainName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2015-01-01/packages/update',
    description=""" Updates a package for use with Amazon ES domains. """,
    tags=['package_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_package(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: Field20150101PackagesUpdatePostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/2015-01-01/packages/{PackageID}',
    description=""" Delete the package. """,
    tags=['package_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_package(
    package_i_d: str = Path(..., alias='PackageID'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2015-01-01/packages/{PackageID}/domains',
    description=""" Lists all Amazon ES domains associated with the package. """,
    tags=['package_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_domains_for_package(
    package_i_d: str = Path(..., alias='PackageID'),
    max_results: Union[
        Optional[conint(le=100)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='maxResults'),
    next_token: Union[
        Optional[str], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='nextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2015-01-01/packages/{PackageID}/history',
    description=""" Returns a list of versions of the package, along with their creation time and commit message. """,
    tags=['package_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_package_version_history(
    package_i_d: str = Path(..., alias='PackageID'),
    max_results: Union[
        Optional[conint(le=100)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='maxResults'),
    next_token: Union[
        Optional[str], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='nextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2015-01-01/tags',
    description=""" Attaches tags to an existing Elasticsearch domain. Tags are a set of case-sensitive key value pairs. An Elasticsearch domain may have up to 10 tags. See <a href="http://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-managedomains.html#es-managedomains-awsresorcetagging" target="_blank"> Tagging Amazon Elasticsearch Service Domains for more information.</a> """,
    tags=['package_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def add_tags(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: Field20150101TagsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/2015-01-01/tags-removal',
    description=""" Removes the specified set of tags from the specified Elasticsearch domain. """,
    tags=['package_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def remove_tags(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: Field20150101TagsRemovalPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/2015-01-01/tags/#arn',
    description=""" Returns all tags for the given Elasticsearch domain. """,
    tags=['vpc_access_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_tags(
    arn: str,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
